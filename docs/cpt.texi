\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename cpt.info
@settitle Carbs Packaging Tools
@documentencoding UTF-8
@documentlanguage en
@c %**end of header

@copying
Copyright @copyright{} 2020-2021 Cem Keylan

@quotation
Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version 1.3 or any later version
published by the Free Software Foundation; with no Invariant Sections, with no
Front-Cover Texts and no Back-Cover Texts. A copy of the license is included in
the section entitled "GNU Free Documentation License."

@end quotation
@end copying

@dircategory Development
@direntry
* Carbs Packaging Tools: (cpt). Carbs Package Management Library.
@end direntry

@finalout
@titlepage
@title Carbs Packaging Tools
@subtitle User Manual
@author Cem Keylan
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Carbs Packaging Tools

This is a reference document containing both the user-guide and the development
manual for @strong{Carbs Packaging Tools}. For development logs see @uref{https://git.carbslinux.org/cpt, the git repository}.
@end ifnottex

@menu
* Preface::                      Introduction to Carbs Packaging Tools
* Usage::                        Basic usage of Carbs Packaging Tools
* Configuration::                Configuring the package manager
* Packaging System::             More detail on creating packages
* Package Repositories::         Ways of distributing packages
* Comparison Between CPT and KISS::
* CPT Library::                  Documentation of the Library
* Concept Index::                Concepts mentioned in this manual
* Variable Index::               Variables mentioned in this manual

@detailmenu
--- The Detailed Node Listing ---

Configuration

* CPT Base::                     Defining base packages
* Environment Variables::        Change the behaviour of cpt through environment configuration
* Hooks::                        Use hooks to customize the package manager operations
* Editing the build file during pre-build:: Modify a package build with your hooks

Environment Variables

* @samp{CPT_PATH}::              Set the locations of your repositories
* @samp{CPT_COMPRESS}::          Compression tool to use in cpt
* @samp{CPT_FORCE}::             Force operations on cpt
* @samp{CPT_PID}::               Set reproducible temporary directories

Packaging System

* build::                        The build script
* sources::                      The file containing package sources
* checksums::                    The file containing sha256sum of the sources
* version::                      The file containing the version and the release numbers of a package
* depends::                      The file containing the dependencies of a package
* meta::                         File containing more information on packages
* post-install::                 The post-installation script
* message::                      The post-installation message to be displayed
* test::                         The test script for a package

Package Repositories

* Rsync Repositories::           Information on using or creating rsync repositories
* Fossil repositories::          Advantages and disadvantages of Fossil
* Message of the Day::           Communicate with the users using your repository

Rsync Repositories

* Setting up an Rsync repository:: Set up a repository for distribution

CPT Library

* Calling the library::          Including the library on your code
* Option parsing::               Easy way of parsing options with cpt-lib
* Message functions::            Communicate to users
* Text functions::               Manipulate or check text
* Portability functions::        Functions to replace non-POSIX commands
* System Functions::             Functions to manipulate your system
* Package Functions::            Manipulate, or query anything related to packages

Option parsing

* Defining a parser::            Correct way of using getoptions
* @samp{global_options()}::      Convenience function for defining common flags

Message functions

* @samp{out()}::                 Print a message as-is
* @samp{log()}::                 Print a message prettily
* @samp{die()}::                 Print a message and exit with error
* @samp{warn()}::                Print a warning message
* @samp{prompt()}::              Ask the user whether they want to continue

Text functions

* @samp{contains()}::            Check if a "string list" contains a word
* @samp{regesc()}::              Escape regular expression characters
* @samp{pop()}::                 Remove an item from a string list
* @samp{sepchar()}::             Separate characters from a string

Portability functions

* @samp{_seq()}::                'seq(1)' but no newline
* @samp{_stat()}::               'stat %U' replacement
* @samp{_readlinkf()}::          'readlink -f' replacement

System Functions

* @samp{as_root()}::             Run a command as the root user

Package Functions

* @samp{pkg_build()}::
* @samp{pkg_depends()}::
* @samp{pkg_order()}::
* @samp{pkg_owner()}::           Check which package owns the given file
* @samp{pkg_isbuilt()}::         Check whether the given package is built
* @samp{pkg_lint()}::            Check whether a package directory fits the standards
* @samp{pkg_find()}::            Query package locations
* @samp{pkg_get_base()}::        List system base packages
* @samp{pkg_gentree()}::         Generate a dependency tree for the given package
* @samp{pkg_query_meta()}::

@end detailmenu
@end menu

@node Preface
@chapter Preface

Carbs Linux uses its own package management toolchain named @samp{cpt} which was
initially forked from the @uref{https://github.com/kisslinux/kiss, kiss} package manager. Unlike @samp{kiss}, however, its main
goal is being easily extendable. Instead of being a single file package manager,
it revolves around the shell library @samp{cpt-lib}, and many tools that wrap around
it. This document aims to document both the usage of the distributed tools and
document the library functions.

@node Usage
@chapter Usage

@samp{cpt} is formed of many tools combined in a single environment, similar to
@samp{git}. When you run @samp{cpt} without any arguments, it will show all available
tools and their explanations. Here is an example call with extra scripts on my
system:

@example
-> Carbs Packaging Tool
-> add               Commit the current directory as a new package
-> alternatives      List and swap to alternatives
-> build             Build a package
-> bump              Commit the current directory as a version bump
-> cargo-urlgen      Create static cargo sources for Rust packages
-> cargolock-urlgen  Convert the given Cargo.lock file to sources
-> cat               Concatanate package files in the installed package database
-> changelog         Print the git log of the specific package
-> chbuild           Create/destroy temporary chroots
-> checkmissing      Verify package manifests
-> checksum          Generate checksums
-> chroot            Enter a chroot
-> commit            Commit a package without the prefix of 'package:'
-> depends           Display a package's dependencies
-> download          Download sources for the given package
-> exec              Execute a command inside the alternatives system
-> export            Turn an installed package into a CPT tarball
-> fork              Fork a package to the current directory
-> getchoice         Prints the full path to a file in the alternatives system.
-> install           Install a package
-> link              Link a forked package's files to the other repository
-> list              List installed packages
-> maintainer        Find the maintainer of a package
-> manifest          Display all files owned by a package
-> manifest-tree     Display all files owned by a package with a tree view
-> new               Create a boilerplate CPT package
-> orphans           List orphaned packages
-> owns              Check which package owns a file
-> rel               Bump the release number of a package
-> remove            Remove a package
-> repodepends       Display a package's dependencies in the repository
-> reporevdepends    Display packages on the repository which depend on package
-> reset             Remove all packages except for the base
-> revdepends        Display packages which depend on package
-> search            Search for a package
-> size              Show the size on disk for a package
-> source            Extract sources of a given package to the current directory
-> update            Check for updates
@end example

The documentation of @samp{cpt} aims to keep tool flags and related usage information
on concise manual pages, while moving the rest of the information to this User
Manual to avoid unwarranted duplication. To learn more on a specific usage of a
tool, use the @code{man} program:

@example
man cpt-build
@end example

@node Configuration
@chapter Configuration

The package manager does @strong{NOT} have a configuration file, but there are a
variety of ways in order to interact with and configure the package manager.

@menu
* CPT Base::                     Defining base packages
* Environment Variables::        Change the behaviour of cpt through environment configuration
* Hooks::                        Use hooks to customize the package manager operations
* Editing the build file during pre-build:: Modify a package build with your hooks
@end menu

@node CPT Base
@section CPT Base

An @samp{/etc/cpt-base} file can be used in order to define the base to the package
manager. Base packages are the packages that receive special treatment by
utilities such as @samp{cpt-reset}, and @samp{cpt-orphans}.

@example
# This file defines the base packages of the system. You can add or remove
# package names in order to redefine the base. This file will be used by
# cpt-orphans and cpt-reset. If this file doesn't exist on /etc/cpt-base, both
# of the tools will assume that there is no defined base, so use with caution.
baselayout
binutils
byacc
busybox
bzip2
ca-certificates
curl
flex
gcc
git
rsync
gzip
cpt
bearssl
linux-headers
m4
make
musl
pkgconf
xz
zlib
@end example

@node Environment Variables
@section Environment Variables

Since there is no configuration file for @samp{cpt}, the package manager is
configured through environment variables. These can be set per operation, or be
set to your shell configuration or @samp{~/.profile}. Here are the environment
variables that alter the behaviour of @samp{cpt}, some of them have separate sections
to provide detailed information.

@table @asis
@item @code{CPT_PATH}
@vindex CPT_PATH
Set the locations of your repositories. It is similar to the @code{PATH} variable.
@item @code{CPT_CACHE} 
@vindex CPT_CACHE
The cache directory for @samp{cpt}. Default: @code{$XDG_CACHE_HOME/cpt}.
@item @code{CPT_CHOICE}
@vindex CPT_CHOICE
If this is set to 0, a package installation will be aborted on conflicts.
@item @code{CPT_COLOR}
@vindex CPT_COLOR
If this is set to 1, @samp{cpt} tools will be forced to display coloured output. If
set to 0, they will be forced to display them without colours. Otherwise,
@samp{cpt} will output colour as long as it is outputting to a terminal.
@item @code{CPT_DEBUG}
@vindex CPT_DEBUG
If set to 1, temporary directories will not be removed after the operation.
@item @code{CPT_FETCH}
@vindex CPT_FETCH
If set to 0, @code{cpt-update} will not fetch repositories.
@item @code{CPT_FORCE}
@vindex CPT_FORCE
If set to 1, @samp{cpt} tools will force operation.
@item @code{CPT_HOOK}
@vindex CPT_HOOK
Absolute path to the package manager hook file.
@item @code{CPT_KEEPLOG}
@vindex CPT_KEEPLOG
If set to 1, @samp{cpt} will keep logs regardless of operation success.
@item @code{CPT_PID}
@vindex CPT_PID
Set the temporary build directory name.
@item @code{CPT_PROMPT}
@vindex CPT_PROMPT
If set to 0, @samp{cpt} will not prompt you for anything.
@item @code{CPT_REPO_CACHE}
@vindex CPT_REPO_CACHE
If set to 0, @samp{cpt} will not use or write repository information cache.
@item @code{CPT_ROOT}
@vindex CPT_ROOT
If this variable is set, @samp{cpt} will assume the given path as the system root.
@item @code{CPT_TEST}
@vindex CPT_TEST
If set to 1, @code{cpt-build} will run tests whenever available.
@item @code{CPT_TMPDIR}
@vindex CPT_TMPDIR
The directory to create the temporary directories.
@end table

@menu
* @samp{CPT_PATH}::              Set the locations of your repositories
* @samp{CPT_COMPRESS}::          Compression tool to use in cpt
* @samp{CPT_FORCE}::             Force operations on cpt
* @samp{CPT_PID}::               Set reproducible temporary directories
@end menu

@node @samp{CPT_PATH}
@subsection @samp{CPT_PATH}

@cindex Setting up repositories
Similar to the @samp{PATH} variable, @samp{cpt} find repositories from the @samp{CPT_PATH}
variable. Here is an example:

@example
CPT_PATH=$HOME/repos/repo1:$HOME/repos/repo2:$HOME/repos/repo3
@end example

This is a simplistic and a structured example for repository locations, but it
doesn't necessarily need to be as tidy as the example above. Here is an example
for something a little more complex.

@example
CPT_PATH=$HOME/repos/overrides:/var/db/cpt/repo/core:/var/db/cpt/repo/extra:$HOME/repos/personal
@end example

This example brings us to the next section of this document.

@enumerate
@item
Repository preferences


@cindex package conflicts
When you are using multiple repositories from multiple vendors, you will find
out that some repositories have the same packages. @samp{cpt} doesn't care about
conflicting packages. If you want to build a package that exists on multiple
repositories, @samp{cpt} will build the first matching package. This means that if
@samp{grep} package (for the sake of an example) exists on both
@samp{$HOME/repos/personal} and @samp{$HOME/repos/carbs/extra}, and you want
to install from your personal repository, you must set @samp{CPT_PATH} so that your
personal repository is listed before the @samp{extra} repository.

@example
CPT_PATH=$HOME/repos/personal:$HOME/repos/carbs/extra
@end example

@item
Setting the @samp{CPT_PATH}


You can set the @samp{CPT_PATH} variable on your shell configuration or your
@samp{.profile} file in a way that is easy to read.

The below example sets @samp{CPT_PATH} in a way that is easy to understand which
repository comes first:

@example
CPT_PATH=$HOME/repos/overrides
CPT_PATH=$CPT_PATH:$HOME/repos/carbs/core
CPT_PATH=$CPT_PATH:$HOME/repos/carbs/extra
CPT_PATH=$CPT_PATH:$HOME/repos/carbs/xorg
CPT_PATH=$CPT_PATH:$HOME/repos/personal
export CPT_PATH
@end example
@end enumerate

@node @samp{CPT_COMPRESS}
@subsection @samp{CPT_COMPRESS}

When setting the @samp{CPT_COMPRESS} value, you should set the name of the default
suffixes for the program. Available values are:

@itemize
@item
@samp{gz}
@item
@samp{zst}
@item
@samp{bz2}
@item
@samp{xz}
@item
@samp{lz}
@end itemize

Defaults to @samp{gz}.

@node @samp{CPT_FORCE}
@subsection @samp{CPT_FORCE}

If this is set to 1, some of the @samp{cpt} tools will continue regardless of
errors or skip certain checks. Here are some examples:

@itemize
@item
@samp{cpt-install} will install a package without verifying its manifest.
@item
@samp{cpt-install} will install a package even when there are missing dependencies.
@item
@samp{cpt-remove} will remove packages even when there are other packages that
depend on the current package.
@end itemize

Defaults to 0.

@node @samp{CPT_PID}
@subsection @samp{CPT_PID}

If this variable is set, the temporary files will be created with this variable
as the suffix, instead of the PID of the @samp{cpt} process. The advantage is that
you can know exactly where the build directory is located, while the
disadvantage is that there will be issues with multiple operations at the same
time. So the best way to use this variable is during one-time @samp{cpt} calls.

@example
CPT_PID=mesa cpt b mesa
@end example

By running the above, you will know that the created build directories will end
with the @samp{*-mesa} suffix.

@node Hooks
@section Hooks

Hooks can be used in order to change the runtime behaviour of the package manager.
There are a variety of package hooks, mostly self explanatory:

@table @asis
@item pre-build   
Run just before the @code{build} script is run
@item post-build  
Run after the @code{build} script is run successfully
@item build-fail  
Run if the @code{build} script fails
@item pre-test    
Run before the @code{test} script is run
@item test-fail   
Run if the @code{test} script fails
@item pre-install 
Run before a package is installed for each package
@item post-install
Run after a package is installed for each package
@item pre-remove  
Run before a package is removed for each package
@item post-remove 
Run after a package is removed for each package
@item pre-fetch   
Run before all repositories are fetched
@item post-fetch  
Run after all repositories are fetched
@item post-package
Run after a tarball for a package is created
@end table

In order to use hooks, you will need to set the @samp{CPT_HOOK} variable pointing to
your hook file. Your hook file @strong{MUST} be a POSIX shell script as its contents
are sourced by the package manager.

The hook is given 3 variables when it is executed. Those are:

@table @asis
@item @code{$TYPE}
The type of the hook, (@samp{pre-build}, @samp{post-build}, etc.)
@item @code{$PKG} 
The package that @samp{cpt} is currently working on. Can be null.
@item @code{$DEST}
The destination of the operation. Can be null.
@end table

@node Editing the build file during pre-build
@section Editing the build file during pre-build

You can edit the @samp{build} file during pre-build. The file is copied from the
repository to the build directory named as @samp{.build.cpt}. You can use @samp{sed} or
any other tool to edit the build file. After the build is complete, a @samp{diff}
file will be placed to the package database named as @samp{build.diff}. Here is an
example @samp{build} file manipulation during the pre-build hook.

@example
cat <<EOF> .build.cpt
#!/bin/sh -e

for patch in bash50-0??; do
    patch -p0 < "\$patch"
done

export LDFLAGS=-static

./configure \
    --prefix=/usr \
    --without-bash-malloc \
    --disable-nls

export MAKEFLAGS="TERMCAP_LIB=/usr/lib/libncursesw.a $MAKEFLAGS"

make
make DESTDIR="\$1" install

ln -s bash "\$1/usr/bin/sh"
EOF
@end example

@node Packaging System
@chapter Packaging System

A package is a directory formed of several files, from these files, only
@code{build}, @code{checksums}, and @code{version} files are mandatory.

This section talks about files that are interpreted specially by the package
manager. Any other file can be added to the package directory at the discretion
of the package maintainer. Everything in the package directory will also be
added to the package database that is located on @samp{/var/db/cpt/installed}. These
can be patches, configuration files, etc.

@menu
* build::                        The build script
* sources::                      The file containing package sources
* checksums::                    The file containing sha256sum of the sources
* version::                      The file containing the version and the release numbers of a package
* depends::                      The file containing the dependencies of a package
* meta::                         File containing more information on packages
* post-install::                 The post-installation script
* message::                      The post-installation message to be displayed
* test::                         The test script for a package
@end menu

@node build
@section build

Typically @samp{build} files are shell scripts that run commands to prepare the source
code to be installed on the target system. Even though we will be assuming that
the @samp{build} file is a POSIX shell script (for portability's sake), @samp{build}
files can be any executable program from binary programs to @samp{perl} scripts.

The contents of a build script do not need to follow a certain rule for the
package manager, except for the fact that the user needs the permission to
execute the file.

An important advice is to append an '-e' to the shebang (#!/bin/sh -e) so that
the build script exits on compilation error.

Build is run with three arguments (@samp{$#})

@itemize
@item
Location of the package directory (DESTDIR)
@item
Package version
@item
System architecture
@end itemize

@node sources
@section sources

@samp{sources} file is a list of files and sources that will be put to the build
directory during the build process. Those can be remote sources (such as tarballs),
git repositories, and files that reside on the package directory.

The syntax is pretty simple for the @samp{soures} file; @samp{src dest}. The @samp{dest}
parameter is optional. It is the directory that the source will be placed in.
Here is the @samp{sources} file for the @samp{gst-plugins} package:

@example
https://gstreamer.freedesktop.org/src/gst-plugins-good/gst-plugins-good-1.16.2.tar.xz good
https://gstreamer.freedesktop.org/src/gst-plugins-bad/gst-plugins-bad-1.16.2.tar.xz   bad
https://gstreamer.freedesktop.org/src/gst-plugins-ugly/gst-plugins-ugly-1.16.2.tar.xz ugly
https://gstreamer.freedesktop.org/src/gst-libav/gst-libav-1.16.2.tar.xz               libav
@end example

This file is read from the package manager as space seperated. Files that begin
with a @samp{#} comment are ignored. The first value points to the location of the
source.

If it starts with a protcol url, (such as @uref{ftp://} @uref{http://} @uref{https://}) it will be
downloaded with @samp{curl}.

If the source is a git repository, it shall be prefixed with a @samp{git+} git(1) will
be used to do a shallow clone of the repository. If the commit is suffixed by a
history pointer, git will checkout the relevant revision. So,

@table @asis
@item @samp{git+git://example.com/pub/repo@@v1.2.3}
will checkout the tag named "v1.2.3"
@item @samp{git+git://example.com/pub/repo#development}
will checkout the branch named "development"
@item @samp{git+git://example.com/pub/repo#1a314s87}
will checkout the commit named "1a314s87"
@end table

Other files are assumed to be residing in the package directory. They should be
added with their paths relative to the package directory.

@node checksums
@section checksums

@samp{checksums} file is generated by the @code{cpt c pkg} command. It is generated
according to the order of the sources file. That's why you shouldn't be editing
it manually. The checksums file is created with the digests of the files using
the sha256 algorithm.

@node version
@section version

The version file includes the version of the software and the release number of
of the package on a space seperated format. The contents of the file should look
like below.

@example
1.3.2 1
@end example

@node depends
@section depends

This is a list of dependencies that must be installed before a package build. You
can append "make" after a dependency to mark a package is only required during
the build process of a package. Packages marked as a make dependency can be
removed after the build. There are also "test" dependencies. These dependencies
are only installed if either the @samp{CPT_TEST} is set to 1, or the build is run
with the @samp{-t} or @samp{--test} options. So, a package package could have
the following @samp{depends} file:

@example
linux-headers make
python        test
zlib
@end example

@node meta
@section meta

@samp{meta} is a non-mandatory package file that can be used to provide information
otherwise non-relevant to the functions of the package manager. This file can
later be queried with the @ref{@samp{pkg_query_meta()}, , pkg@math{_query}@math{_meta}()} function. The file has a simple
markup format, it must adhere to the @samp{KEY: VAL} format. An example for the @samp{cpt}
package would be as follows:

@example
description: Carbs Packaging Tools
license: MIT
maintainer: Linux User <linux-user@@example.com>
@end example

@node post-install
@section post-install

@samp{post-install} files have the same requirements as the build script. They
will be run after the package is installed as root (or as the user if the user
has write permissions on @samp{CPT_ROOT}).

@node message
@section message

This plaintext file will be outputted with @samp{cat} after every package is
installed.

@node test
@section test

@vindex CPT_TEST
Test files are mainly for the repository maintainer to test the packages, and
will only run if the user has the @samp{CPT_TEST} variable set, or the build is
run with the @samp{-t} or @samp{--test} options. This script is run on the
build directory. It is run right after the build script is finished.

@node Package Repositories
@chapter Package Repositories

@strong{cpt} has backends to support the use of a variety of distribution methods. You
can currently use Git, Mercurial, Fossil, and Rsync to distribute a package
repository. That, however, does not mean that you need to setup either of those,
if you are simply going for a local repository on your system.

@cindex Setting up repositories
In the broad sense, a package repository is any directory that contains packages
that were described in @ref{Packaging System}. This means that as long as you can
serve them, there is not much needed to do in order to distribute a repository.
The following subsections aim to detail the notes and the caveats of certain
distribution methods.

@menu
* Rsync Repositories::           Information on using or creating rsync repositories
* Fossil repositories::          Advantages and disadvantages of Fossil
* Message of the Day::           Communicate with the users using your repository
@end menu

@node Rsync Repositories
@section Rsync Repositories

Rsync repositories are simple to serve and simple to use. In the repository
directory, there needs to be a @samp{.rsync} file that points to the remote of the
repository. This is used in order to fetch changes from the upstream. @samp{.rsync}
file looks like this for the core repository:

@example
rsync://carbslinux.org/repo/core
@end example

Rsync repositories have some few distinctions when it comes to fetching them.
They can be either synced individually or as a "root". There are 2 important
files, those are @samp{.rsync} and @samp{.rsync_root}. Here is the Carbs Linux
rsync repository structure.

@example
           /
   -----------------
  |                |
.rsync           core/
          ----------------
          |              |
        .rsync      .rsync_root
@end example

Unlike git repositories, they don't have a defined "root" directory. This is
both an advantage and a disadvantage. This way, we can sync individual
repositories, but that also means we need extra files to define root directories
and repository locations. Here is the content for each of these files:

@example
/.rsync:           rsync://carbslinux.org/repo
/core/.rsync:      rsync://carbslinux.org/repo/core
/core/.rsync_root: ..
@end example

The @samp{.rsync_root} file on the core repository points to the upper directory.
If a @samp{.rsync} file exists on the upper directory, this means that is the whole
repository and will sync the entire repository instead of each individual repository.

If the upper directory doesn't have this @samp{.rsync} file, this means that this
is an individual repository, and the package manager will fetch accordingly.

@menu
* Setting up an Rsync repository:: Set up a repository for distribution
@end menu

@node Setting up an Rsync repository
@subsection Setting up an Rsync repository

Carbs Linux repositories automatically sync from the git repostitories and serve
it through the rsync daemon. Here is a sample shell script that I use in order to
sync repositories. Feel free to customize for your own use.

@example
#!/bin/sh
HOSTNAME="rsync://carbslinux.org/repo"
GITDIR="/pub/git/repo"
SHAREDIR="/pub/share/repo"
git -C "$GITDIR" pull

rsync -avcC --delete --include=core --exclude=.rsync,.rsync_root "$GITDIR/." "$SHAREDIR"

printf '%s\n' "$HOSTNAME" > "$GITDIR/.rsync"
for dir in "$GITDIR/"*; do
    [ -d "$dir" ] || continue
    [ -f "$dir/.rsync" ] ||
    printf '%s/%s\n' "$HOSTNAME" "$@{dir##*/@}" > "$dir/.rsync"
    printf '..\n' > "$dir/.rsync_root"
done
@end example

You can then create an @strong{rsync} user for serving the repositories.

@example
$ adduser -SD rsync
@end example

Create @samp{/etc/rsyncd.conf} and a service configuration as well.

@example
uid = rsync
gid = rsync
address = example.com
max connections = 10
use chroot = yes

[repo]
    path = /pub/share/repo
    comment = My repository
@end example

Create a service file at @samp{/etc/sv/rsync/run} (runit):

@example
#!/bin/sh -e
exec rsync --daemon --no-detach
@end example

@node Fossil repositories
@section Fossil repositories

Setting up a Fossil repository is no different than setting up any other
repository. There are certainly many advantages of using Fossil as a means of
distributing packages. You can create a Linux distribution and have your
website, forum, documentation, and your package repository entirely contained
inside a single Fossil repository. Fossil's built-in wiki and forum features
make it the ultimate single-tool distribution software.

However, the biggest caveat of Fossil is that it doesn't allow symlinks by
default unless it's manually set by the user, and this feature cannot even be
set globally. Symbolic links aren't quite common within distribution
repositories, but they come in handy where there are two packages that use the
same source files (@samp{emacs} and @samp{emacs-nox}, or @samp{libelf} and @samp{libdw} from
elfutils). If symbolic links are too big of a deal for your repository, this can
be a huge issue for you.

@node Message of the Day
@section Message of the Day

If a file named @samp{motd} is found on the root directory of the package repository,
its contents will be printed to the standard output when the users are updating
their repositories. This method can be used to communicate messages to the
users, such as package removals or otherwise important information.

@node Comparison Between CPT and KISS
@chapter Comparison Between CPT and KISS

Lots of things have changed since @code{cpt} was forked from @code{kiss} in terms of
functionalities and ideals. This section aims to describe the similarities and
differences of both package managers as neutral as possible. Keep in mind that
this is the @code{cpt} documentation, so it may be biased regardless.

@table @asis
@item Package Manager
While @code{kiss} aims to be a simple single file package manager, @code{cpt} aims to be
an extendable package manager library. @code{kiss} has all of its features
built-in, while @code{cpt} has all of its features separated into small tools.
These tools can be called from the main @code{cpt} tool (in order to keep
@code{kiss}-like usage) or with their names directly (e.g @code{cpt-build}).

@item Configuration
Neither @code{kiss} nor @code{cpt} use configuration files. Instead, they are configured
through environment variables. Additionally, all @code{cpt} tools can receive flags
that alter their functionality. @code{kiss} does not accept flags.

@item Package Repositories
In addition to git repositories, @code{cpt} also supports Rsync, Fossil, and
Mercurial repositories.

@item Package Sources
In addition to git repositories for sources, @code{cpt} also supports Mercurial and
Fossil repositories.

@item Post-Installation Messages
@code{kiss} and @code{cpt} interact with @samp{post-install} messages differently. @code{kiss}
does not differentiate between post-installation scripts and post-installation
messages, and will save the output of all scripts named @samp{post-install} to be
printed after the installation of all packages are complete. @code{cpt} on the
other hand, separates these with the @samp{message} file. @code{cpt} runs @samp{post-install}
without saving the output to be printed a second time. It instead prints all
@samp{message} files after the installation is over.

@item Portability
@code{kiss} aims to be as portable as possible. @code{cpt} aims to be portable, but
favours performance. @code{cpt} depends on @code{rsync} for package installation, while
@code{kiss} has removed the dependency in favour of portability.
@end table

@node CPT Library
@chapter CPT Library

@samp{cpt-lib} is the library of Carbs Packaging Tools which can be used to extend
the functionality of the package manager. This is the API documentation of the
package manager library.

@menu
* Calling the library::          Including the library on your code
* Option parsing::               Easy way of parsing options with cpt-lib
* Message functions::            Communicate to users
* Text functions::               Manipulate or check text
* Portability functions::        Functions to replace non-POSIX commands
* System Functions::             Functions to manipulate your system
* Package Functions::            Manipulate, or query anything related to packages
@end menu

@node Calling the library
@section Calling the library

You can call the library on your scripts by adding the following line to your
files:

@example
#!/bin/sh -e
. cpt-lib
@end example

This will load the library inside your script, and will set some environment
variables that are used inside the package manager.

@node Option parsing
@section Option parsing

@samp{cpt-lib} includes a POSIX-shell option parser inside named @samp{getoptions}. You
can see its own @uref{https://github.com/ko1nksm/getoptions/blob/v2.5.0/README.md, documentation} for writing an option parser. The built-in version
of the @samp{getoptions} library is 2.5.0 and there are no plans for updating it
apart from bug fixes.

@menu
* Defining a parser::            Correct way of using getoptions
* @samp{global_options()}::      Convenience function for defining common flags
@end menu

@node Defining a parser
@subsection Defining a parser

Some functions are called and set automatically when you call @samp{cpt-lib}, so you
shouldn't define the option parser after calling the library, as some of the
variables will already be set.

If the function @samp{parser_definition()} as defined when @samp{cpt-lib} is called,
cpt-lib will handle the option parsing itself by calling @samp{getoptions}
inside. Here is the proper way of doing it.

@example
#!/bin/sh -e

parser_definition() @{
    # The rest arguments MUST be defined as 'REST'
    setup REST help:usage                  -- "usage: $@{0##*/@} [options] [pkg...]"
    msg                                    -- '' 'Options:'
    flag CPT_TEST -t export:1 init:@@export -- "Enable tests"

    global_options
@}

. cpt-lib
@end example

@node @samp{global_options()}
@subsection @samp{global_options()}

The @samp{global_options()} function is a simple convenience call to include flags
that can be used inside most @samp{cpt} tools. It defines the following flags:

@multitable {aaaa} {aaaaaaaaaaaaa} {aaaaaaaaaaaa}
@headitem Flag
@tab Long Option
@tab Calls
@item @code{-f}
@tab @code{--force}
@tab @samp{CPT_FORCE}
@item @code{-y}
@tab @code{--no-prompt}
@tab @samp{CPT_PROMPT}
@item 
@tab @code{--root}
@tab @samp{CPT_ROOT}
@item @code{-h}
@tab @code{--help}
@tab @samp{usage()}
@item @code{-v}
@tab @code{--version}
@tab @samp{version()}
@end multitable

@node Message functions
@section Message functions

@samp{cpt} has various functions to print information to users.

@menu
* @samp{out()}::                 Print a message as-is
* @samp{log()}::                 Print a message prettily
* @samp{die()}::                 Print a message and exit with error
* @samp{warn()}::                Print a warning message
* @samp{prompt()}::              Ask the user whether they want to continue
@end menu

@node @samp{out()}
@subsection @samp{out()}

@samp{out()} is a really simple function that prints messages to the standard
output. It prints every argument with a newline. It is not meant to communicate
with the user, it just exists to have a simple function to interact with other
functions.

@example
$ out "This is an example call" "How are you?"
This is an example call
How are you?
@end example

@node @samp{log()}
@subsection @samp{log()}

@samp{log()} is the most commonly used message function in the package manager. It is
used to pretty print messages with visual cues, so it is easier to read and
understand for the users. It changes message output for each argument it
receives (takes up to three arguments).

@itemize
@item
If it takes a single argument, it prints a yellow leading arrow followed by
colorless text.
@item
If it takes two arguments, it prints a yellow leading arrow followed by the
first argument (colored blue), and then followed by colorless second argument.
@item
If it takes three arguments, instead of a yellow arrow, it prints the third
argument in yellow, followed by the same two arguments as above.
@end itemize

@node @samp{die()}
@subsection @samp{die()}

@samp{die()} wraps the @samp{log()} function and exits with an error (1). It takes one or
two arguments, which are sent to the @samp{log()} function. The third argument for
@samp{log()} is set as @samp{!>}.

@node @samp{warn()}
@subsection @samp{warn()}

@samp{warn()} is another function that wraps @samp{log()}. In place of the third argument,
it uses the word @samp{WARNING}.

@node @samp{prompt()}
@subsection @samp{prompt()}

@samp{prompt()} is an interactive function that waits for user input to continue.
It takes a single argument string to print a message, and then asks the user
whether they want to continue or not. Prompts can be disabled by the user if
they use a flag to disable them or set @samp{CPT_PROMPT} to 0.

@node Text functions
@section Text functions

Following functions are used to manipulate, check, or interact with text.

@menu
* @samp{contains()}::            Check if a "string list" contains a word
* @samp{regesc()}::              Escape regular expression characters
* @samp{pop()}::                 Remove an item from a string list
* @samp{sepchar()}::             Separate characters from a string
@end menu

@node @samp{contains()}
@subsection @samp{contains()}

@samp{contains} function can be used to check whether a list variable contains a
given string. If the string is inside the list, it will return 0, otherwise 1.

@example
# Usage
contains "$LIST" foo

contains "foo bar" foo  # Returns 0
contains "foo bar" baz  # Returns 1
@end example

@node @samp{regesc()}
@subsection @samp{regesc()}

@samp{regesc()} can be used to escape regular expression characters that are defined
in POSIX BRE@. Those characters are, @samp{$}, @samp{.}, @samp{*}, @samp{[}, @samp{\\}, and @samp{^}.

@example
regesc '^[$\'  # Returns \^\[\$\\
@end example

@node @samp{pop()}
@subsection @samp{pop()}

@samp{pop()} can be used to remove a word from a "string list" without a @samp{sed}
call. Word splitting is intentional when using this function.

@example
# Usage
pop foo from $LIST

pop foo from foo baz bar # Returns baz bar
@end example

@node @samp{sepchar()}
@subsection @samp{sepchar()}

This function can be used to separate characters from the given string without
resorting to external resources.

@example
sepchar mystring
# Prints:
# m
# y
# s
# t
# r
# i
# n
# g
@end example

@node Portability functions
@section Portability functions

These helper functions are used so that we don't depend on non-POSIX programs for
certain functionality. They are prefixed with the @samp{_} character.

@menu
* @samp{_seq()}::                'seq(1)' but no newline
* @samp{_stat()}::               'stat %U' replacement
* @samp{_readlinkf()}::          'readlink -f' replacement
@end menu

@node @samp{_seq()}
@subsection @samp{_seq()}

This function is similar to @samp{seq(1)} except that it only takes a single argument
and doesn't print any newlines. It is suitable to be used in @samp{for} loops.

@example
_seq 5
# Prints:
# 1 2 3 4 5
@end example

@node @samp{_stat()}
@subsection @samp{_stat()}

This function imitates @samp{stat %U}. @samp{stat} isn't defined by POSIX, and this is
also a GNU extension. This function returns the owner of a file. If the owner
cannot be found, it will return @samp{root}.

@node @samp{_readlinkf()}
@subsection @samp{_readlinkf()}

This function was taken from @uref{https://github.com/ko1nksm/readlinkf, POSIX sh readlinkf library by Koichi Nakashima}.
@samp{readlink} is also not defined by POSIX, so this function uses @samp{ls} to follow
symbolic links until it reaches the actual file.

@node System Functions
@section System Functions

@menu
* @samp{as_root()}::             Run a command as the root user
@end menu

@node @samp{as_root()}
@subsection @samp{as_root()}

@samp{as_root()} calls the rest of the arguments as a different user. Unless a @code{$user}
environment variable is set, it will call the following arguments as the root
user. It supports the following programs for privilege escalation with the
following order:

@enumerate
@item
@samp{ssu}
@item
@samp{sudo}
@item
@samp{doas}
@item
@samp{su}
@end enumerate

The program called for this operation can be overridden using the @code{$CPT_SU}
variable.

@node Package Functions
@section Package Functions

Obviously, package functions are the most important ones for @samp{cpt-lib}, those
are the ones you will use to build, to query, to manipulate, or to otherwise
interact with packages.

@menu
* @samp{pkg_build()}::
* @samp{pkg_depends()}::
* @samp{pkg_order()}::
* @samp{pkg_owner()}::           Check which package owns the given file
* @samp{pkg_isbuilt()}::         Check whether the given package is built
* @samp{pkg_lint()}::            Check whether a package directory fits the standards
* @samp{pkg_find()}::            Query package locations
* @samp{pkg_get_base()}::        List system base packages
* @samp{pkg_gentree()}::         Generate a dependency tree for the given package
* @samp{pkg_query_meta()}::
@end menu

@node @samp{pkg_build()}
@subsection @samp{pkg_build()}

This function builds all given packages. It resolves dependencies for the given
packages, lints the package, extracts its sources and runs the @code{build} script.

@example
# Example

# Create the cache directories first, this is where the package will be built.
create_cache

# Build the package(s) you want to build.
pkg_build cpt
@end example

@node @samp{pkg_depends()}
@subsection @samp{pkg_depends()}

This function calculates the dependencies for the requested package, returning
the variable @code{$deps}. This variable can then be passed to @ref{@samp{pkg_order()}, , pkg@math{_order}()} in order
to generate an ordered list for building packages.

@node @samp{pkg_order()}
@subsection @samp{pkg_order()}

This function receives package names and returns @code{$order} and @code{$redro} variables
that can be used for building and removing packages.

@node @samp{pkg_owner()}
@subsection @samp{pkg_owner()}

This function can be used to determine the owner of a package. The first
argument is used for flags that will be passed to @samp{grep}, and the second one is
for the file query. Rest of the arguments can be used in order to specify the
manifests to be used, but it is optional. @samp{pkg_owner()} will search for all the
installed packages if no other arguments are given.

@example
# Example
pkg_owner -lFx /usr/bin/grep  # Returns 'busybox'

# An example call made by `pkg_fix_deps()` to figure out whether the built
# package contains the file it depends.
pkg_owner -l "/$@{dep#/@}\$" "$PWD/manifest" >/dev/null && continue
pkg_owner -l "/$@{dep#/@}\$" "$@@" ||:
@end example

@node @samp{pkg_isbuilt()}
@subsection @samp{pkg_isbuilt()}

This function returns with success when the given package has a built tarball
with the matching version and release strings from the repository.

@node @samp{pkg_lint()}
@subsection @samp{pkg_lint()}

This function checks whether a given package fits the proper package
specification. This function @strong{does not return with failure, it exits outright}
if it fails.

@node @samp{pkg_find()}
@subsection @samp{pkg_find()}

@samp{pkg_find()} is the tool for searching packages. It accepts up to 3 arguments.

@table @asis
@item $1: Query
This is the only mandatory argument. It accepts globbing, meaning that shell
wildcards can be used in the query.
@item $2: Match
If this exists @samp{pkg_find()} will print every single match found in the search
path. If it doesn't, @samp{pkg_find()} will print the first match and exit.
@item $3: Type
This is the argument to be passed to the @samp{test} function. Unless this argument
is given, it defaults to @samp{-d}, which tests for directories.
@end table

@example
# Returns the first match of cpt
pkg_find cpt

# Returns all matches of cpt
pkg_find cpt all

# Returns all globbed matches for cpt* (e.g. cpt and cpt-extra)
pkg_find 'cpt*' all

# Returns all matching cpt-* executables on user's PATH
SEARCH_PATH=$PATH pkg_find 'cpt-*' all -x
@end example

@node @samp{pkg_get_base()}
@subsection @samp{pkg_get_base()}

This function returns the base packages as defined in @samp{/etc/cpt-base}. If an
optional argument is present, it will print all package names in a single line.
If it is not given any arguments, it will return one package per line. See @ref{CPT Base} for more information on base packages.

@node @samp{pkg_gentree()}
@subsection @samp{pkg_gentree()}

This function generates a dependency tree for the given package. The output and
the dependency generation can be configured through a series of keys given as
the second argument. Those keys are:

@table @asis
@item @samp{b}
Include the base packages to the dependency tree.
@item @samp{f}
Include the given package itself to the generated tree.
@item @samp{x}
Do not include make dependencies of the package.
@item @samp{r}
Print the generated tree in reverse order.
@item @samp{n}
Print all packages in a single line instead of a package per line.
@end table

@enumerate
@item
Examples


This example uses the @samp{cpt} package for Carbs Linux. The package itself is
listed to depend on @samp{curl} and @samp{rsync}. Here is the output of calling the
function for cpt directly:

@example
$ pkg_gentree cpt
bearssl
ca-certificates
zlib
curl
rsync
@end example

The example above shows that even though @samp{cpt} itself only depends on @samp{curl} and
@samp{rsync}, we also indirectly need @samp{zlib}, @samp{bearssl} (for @samp{curl}), and
@samp{ca-certificates} (for @samp{bearssl}).

@example
# Print the dependency tree reverse sorted in a single line:
$ pkg_gentree cpt rn
rsync curl zlib ca-certificates bearssl
@end example
@end enumerate

@node @samp{pkg_query_meta()}
@subsection @samp{pkg_query_meta()}

This function is used to query the @ref{meta, , meta file} inside package directories. It can
be used to retrieve information on a package that is otherwise irrelevant to the
package manager itself. It takes two arguments, first being the package and the
second being the key to be retrieved. If the package does not have a @samp{meta}
file or the file does not contain the requested key, the function will return
with 1.

@example
$ pkg_query_meta cpt description
Carbs Packaging Tools
@end example

@node Concept Index
@chapter Concept Index

@printindex cp

@node Variable Index
@chapter Variable Index

@printindex vr

@bye